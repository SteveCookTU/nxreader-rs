// automatically generated by the FlatBuffers compiler, do not modify

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod structure {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum NestHoleCrystalEncounter8ArchiveOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NestHoleCrystalEncounter8Archive<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> Follow<'a> for NestHoleCrystalEncounter8Archive<'a> {
        type Inner = NestHoleCrystalEncounter8Archive<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NestHoleCrystalEncounter8Archive<'a> {
        pub const VT_TABLES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NestHoleCrystalEncounter8Archive { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NestHoleCrystalEncounter8ArchiveArgs<'args>,
        ) -> flatbuffers::WIPOffset<NestHoleCrystalEncounter8Archive<'bldr>> {
            let mut builder = NestHoleCrystalEncounter8ArchiveBuilder::new(_fbb);
            if let Some(x) = args.tables {
                builder.add_tables(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn tables(
            &self,
        ) -> Option<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8Table<'a>>,
            >,
        > {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8Table>,
                >,
            >>(NestHoleCrystalEncounter8Archive::VT_TABLES, None)
        }
    }

    impl flatbuffers::Verifiable for NestHoleCrystalEncounter8Archive<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<
                        '_,
                        flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8Table>,
                    >,
                >>("tables", Self::VT_TABLES, false)?
                .finish();
            Ok(())
        }
    }
    #[derive(Default)]
    pub struct NestHoleCrystalEncounter8ArchiveArgs<'a> {
        pub tables: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8Table<'a>>,
                >,
            >,
        >,
    }

    pub struct NestHoleCrystalEncounter8ArchiveBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NestHoleCrystalEncounter8ArchiveBuilder<'a, 'b> {
        #[inline]
        pub fn add_tables(
            &mut self,
            tables: flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'b,
                    flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8Table<'b>>,
                >,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NestHoleCrystalEncounter8Archive::VT_TABLES,
                tables,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NestHoleCrystalEncounter8ArchiveBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NestHoleCrystalEncounter8ArchiveBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleCrystalEncounter8Archive<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for NestHoleCrystalEncounter8Archive<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("NestHoleCrystalEncounter8Archive");
            ds.field("tables", &self.tables());
            ds.finish()
        }
    }
    pub enum NestHoleCrystalEncounter8TableOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NestHoleCrystalEncounter8Table<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> Follow<'a> for NestHoleCrystalEncounter8Table<'a> {
        type Inner = NestHoleCrystalEncounter8Table<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NestHoleCrystalEncounter8Table<'a> {
        pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_GAME_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_ENTRIES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NestHoleCrystalEncounter8Table { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NestHoleCrystalEncounter8TableArgs<'args>,
        ) -> flatbuffers::WIPOffset<NestHoleCrystalEncounter8Table<'bldr>> {
            let mut builder = NestHoleCrystalEncounter8TableBuilder::new(_fbb);
            builder.add_table_id(args.table_id);
            if let Some(x) = args.entries {
                builder.add_entries(x);
            }
            builder.add_game_version(args.game_version);
            builder.finish()
        }

        #[inline]
        pub fn table_id(&self) -> u64 {
            self._tab
                .get::<u64>(NestHoleCrystalEncounter8Table::VT_TABLE_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn game_version(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8Table::VT_GAME_VERSION, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn entries(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8<'a>>>,
        > {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8>>,
            >>(NestHoleCrystalEncounter8Table::VT_ENTRIES, None)
        }
    }

    impl flatbuffers::Verifiable for NestHoleCrystalEncounter8Table<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("table_id", Self::VT_TABLE_ID, false)?
                .visit_field::<u32>("game_version", Self::VT_GAME_VERSION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<
                        '_,
                        flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8>,
                    >,
                >>("entries", Self::VT_ENTRIES, false)?
                .finish();
            Ok(())
        }
    }

    #[derive(Default)]
    pub struct NestHoleCrystalEncounter8TableArgs<'a> {
        pub table_id: u64,
        pub game_version: u32,
        pub entries: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8<'a>>,
                >,
            >,
        >,
    }

    pub struct NestHoleCrystalEncounter8TableBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NestHoleCrystalEncounter8TableBuilder<'a, 'b> {
        #[inline]
        pub fn add_table_id(&mut self, table_id: u64) {
            self.fbb_
                .push_slot::<u64>(NestHoleCrystalEncounter8Table::VT_TABLE_ID, table_id, 0);
        }
        #[inline]
        pub fn add_game_version(&mut self, game_version: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleCrystalEncounter8Table::VT_GAME_VERSION,
                game_version,
                0,
            );
        }
        #[inline]
        pub fn add_entries(
            &mut self,
            entries: flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'b,
                    flatbuffers::ForwardsUOffset<NestHoleCrystalEncounter8<'b>>,
                >,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NestHoleCrystalEncounter8Table::VT_ENTRIES,
                entries,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NestHoleCrystalEncounter8TableBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NestHoleCrystalEncounter8TableBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleCrystalEncounter8Table<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for NestHoleCrystalEncounter8Table<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("NestHoleCrystalEncounter8Table");
            ds.field("table_id", &self.table_id());
            ds.field("game_version", &self.game_version());
            ds.field("entries", &self.entries());
            ds.finish()
        }
    }
    pub enum NestHoleCrystalEncounter8Offset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NestHoleCrystalEncounter8<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> Follow<'a> for NestHoleCrystalEncounter8<'a> {
        type Inner = NestHoleCrystalEncounter8<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NestHoleCrystalEncounter8<'a> {
        pub const VT_ENTRY_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_SPECIES: flatbuffers::VOffsetT = 6;
        pub const VT_ALT_FORM: flatbuffers::VOffsetT = 8;
        pub const VT_LEVEL: flatbuffers::VOffsetT = 10;
        pub const VT_DYNAMAX_LEVEL: flatbuffers::VOffsetT = 12;
        pub const VT_ABILITY: flatbuffers::VOffsetT = 14;
        pub const VT_IS_GIGANTAMAX: flatbuffers::VOffsetT = 16;
        pub const VT_DROP_TABLE_ID: flatbuffers::VOffsetT = 18;
        pub const VT_BONUS_TABLE_ID: flatbuffers::VOffsetT = 20;
        pub const VT_FIELD_09: flatbuffers::VOffsetT = 22;
        pub const VT_FIELD_0A: flatbuffers::VOffsetT = 24;
        pub const VT_FIELD_0B: flatbuffers::VOffsetT = 26;
        pub const VT_FIELD_0C: flatbuffers::VOffsetT = 28;
        pub const VT_FIELD_0D: flatbuffers::VOffsetT = 30;
        pub const VT_NATURE: flatbuffers::VOffsetT = 32;
        pub const VT_IV_HP: flatbuffers::VOffsetT = 34;
        pub const VT_IV_ATK: flatbuffers::VOffsetT = 36;
        pub const VT_IV_DEF: flatbuffers::VOffsetT = 38;
        pub const VT_IV_SPATK: flatbuffers::VOffsetT = 40;
        pub const VT_IV_SPDEF: flatbuffers::VOffsetT = 42;
        pub const VT_IV_SPE: flatbuffers::VOffsetT = 44;
        pub const VT_FIELD_15: flatbuffers::VOffsetT = 46;
        pub const VT_MOVE0: flatbuffers::VOffsetT = 48;
        pub const VT_MOVE1: flatbuffers::VOffsetT = 50;
        pub const VT_MOVE2: flatbuffers::VOffsetT = 52;
        pub const VT_MOVE3: flatbuffers::VOffsetT = 54;
        pub const VT_DYNAMAX_BOOST: flatbuffers::VOffsetT = 56;
        pub const VT_FIELD_1B: flatbuffers::VOffsetT = 58;
        pub const VT_FIELD_1C: flatbuffers::VOffsetT = 60;
        pub const VT_SHIELD: flatbuffers::VOffsetT = 62;
        pub const VT_ADDITIONAL_MOVE1_RATE: flatbuffers::VOffsetT = 64;
        pub const VT_ADDITIONAL_MOVE1: flatbuffers::VOffsetT = 66;
        pub const VT_ADDITIONAL_MOVE1_PP: flatbuffers::VOffsetT = 68;
        pub const VT_ADDITIONAL_MOVE2_RATE: flatbuffers::VOffsetT = 70;
        pub const VT_ADDITIONAL_MOVE2: flatbuffers::VOffsetT = 72;
        pub const VT_ADDITIONAL_MOVE2_PP: flatbuffers::VOffsetT = 74;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NestHoleCrystalEncounter8 { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NestHoleCrystalEncounter8Args,
        ) -> flatbuffers::WIPOffset<NestHoleCrystalEncounter8<'bldr>> {
            let mut builder = NestHoleCrystalEncounter8Builder::new(_fbb);
            builder.add_bonus_table_id(args.bonus_table_id);
            builder.add_drop_table_id(args.drop_table_id);
            builder.add_additional_move2_pp(args.additional_move2_pp);
            builder.add_additional_move2(args.additional_move2);
            builder.add_additional_move2_rate(args.additional_move2_rate);
            builder.add_additional_move1_pp(args.additional_move1_pp);
            builder.add_additional_move1(args.additional_move1);
            builder.add_additional_move1_rate(args.additional_move1_rate);
            builder.add_shield(args.shield);
            builder.add_field_1c(args.field_1c);
            builder.add_field_1b(args.field_1b);
            builder.add_dynamax_boost(args.dynamax_boost);
            builder.add_move3(args.move3);
            builder.add_move2(args.move2);
            builder.add_move1(args.move1);
            builder.add_move0(args.move0);
            builder.add_field_15(args.field_15);
            builder.add_is_gigantamax(args.is_gigantamax);
            builder.add_level(args.level);
            builder.add_alt_form(args.alt_form);
            builder.add_species(args.species);
            builder.add_entry_index(args.entry_index);
            builder.add_iv_spe(args.iv_spe);
            builder.add_iv_spdef(args.iv_spdef);
            builder.add_iv_spatk(args.iv_spatk);
            builder.add_iv_def(args.iv_def);
            builder.add_iv_atk(args.iv_atk);
            builder.add_iv_hp(args.iv_hp);
            builder.add_nature(args.nature);
            builder.add_field_0d(args.field_0d);
            builder.add_field_0c(args.field_0c);
            builder.add_field_0b(args.field_0b);
            builder.add_field_0a(args.field_0a);
            builder.add_field_09(args.field_09);
            builder.add_ability(args.ability);
            builder.add_dynamax_level(args.dynamax_level);
            builder.finish()
        }

        #[inline]
        pub fn entry_index(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_ENTRY_INDEX, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn species(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_SPECIES, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn alt_form(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_ALT_FORM, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn level(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_LEVEL, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn dynamax_level(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleCrystalEncounter8::VT_DYNAMAX_LEVEL, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn ability(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleCrystalEncounter8::VT_ABILITY, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn is_gigantamax(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_IS_GIGANTAMAX, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn drop_table_id(&self) -> u64 {
            self._tab
                .get::<u64>(NestHoleCrystalEncounter8::VT_DROP_TABLE_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn bonus_table_id(&self) -> u64 {
            self._tab
                .get::<u64>(NestHoleCrystalEncounter8::VT_BONUS_TABLE_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_09(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleCrystalEncounter8::VT_FIELD_09, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_0a(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleCrystalEncounter8::VT_FIELD_0A, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_0b(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleCrystalEncounter8::VT_FIELD_0B, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_0c(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleCrystalEncounter8::VT_FIELD_0C, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_0d(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleCrystalEncounter8::VT_FIELD_0D, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn nature(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleCrystalEncounter8::VT_NATURE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn iv_hp(&self) -> i16 {
            self._tab
                .get::<i16>(NestHoleCrystalEncounter8::VT_IV_HP, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn iv_atk(&self) -> i16 {
            self._tab
                .get::<i16>(NestHoleCrystalEncounter8::VT_IV_ATK, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn iv_def(&self) -> i16 {
            self._tab
                .get::<i16>(NestHoleCrystalEncounter8::VT_IV_DEF, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn iv_spatk(&self) -> i16 {
            self._tab
                .get::<i16>(NestHoleCrystalEncounter8::VT_IV_SPATK, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn iv_spdef(&self) -> i16 {
            self._tab
                .get::<i16>(NestHoleCrystalEncounter8::VT_IV_SPDEF, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn iv_spe(&self) -> i16 {
            self._tab
                .get::<i16>(NestHoleCrystalEncounter8::VT_IV_SPE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_15(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_FIELD_15, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn move0(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_MOVE0, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn move1(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_MOVE1, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn move2(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_MOVE2, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn move3(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_MOVE3, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn dynamax_boost(&self) -> f32 {
            self._tab
                .get::<f32>(NestHoleCrystalEncounter8::VT_DYNAMAX_BOOST, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn field_1b(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_FIELD_1B, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_1c(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_FIELD_1C, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn shield(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_SHIELD, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move1_rate(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE1_RATE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move1(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE1, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move1_pp(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE1_PP, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move2_rate(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE2_RATE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move2(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE2, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move2_pp(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE2_PP, Some(0))
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for NestHoleCrystalEncounter8<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("entry_index", Self::VT_ENTRY_INDEX, false)?
                .visit_field::<u32>("species", Self::VT_SPECIES, false)?
                .visit_field::<u32>("alt_form", Self::VT_ALT_FORM, false)?
                .visit_field::<u32>("level", Self::VT_LEVEL, false)?
                .visit_field::<i8>("dynamax_level", Self::VT_DYNAMAX_LEVEL, false)?
                .visit_field::<i8>("ability", Self::VT_ABILITY, false)?
                .visit_field::<u32>("is_gigantamax", Self::VT_IS_GIGANTAMAX, false)?
                .visit_field::<u64>("drop_table_id", Self::VT_DROP_TABLE_ID, false)?
                .visit_field::<u64>("bonus_table_id", Self::VT_BONUS_TABLE_ID, false)?
                .visit_field::<i8>("field_09", Self::VT_FIELD_09, false)?
                .visit_field::<i8>("field_0a", Self::VT_FIELD_0A, false)?
                .visit_field::<i8>("field_0b", Self::VT_FIELD_0B, false)?
                .visit_field::<i8>("field_0c", Self::VT_FIELD_0C, false)?
                .visit_field::<i8>("field_0d", Self::VT_FIELD_0D, false)?
                .visit_field::<i8>("nature", Self::VT_NATURE, false)?
                .visit_field::<i16>("iv_hp", Self::VT_IV_HP, false)?
                .visit_field::<i16>("iv_atk", Self::VT_IV_ATK, false)?
                .visit_field::<i16>("iv_def", Self::VT_IV_DEF, false)?
                .visit_field::<i16>("iv_spatk", Self::VT_IV_SPATK, false)?
                .visit_field::<i16>("iv_spdef", Self::VT_IV_SPDEF, false)?
                .visit_field::<i16>("iv_spe", Self::VT_IV_SPE, false)?
                .visit_field::<u32>("field_15", Self::VT_FIELD_15, false)?
                .visit_field::<u32>("move0", Self::VT_MOVE0, false)?
                .visit_field::<u32>("move1", Self::VT_MOVE1, false)?
                .visit_field::<u32>("move2", Self::VT_MOVE2, false)?
                .visit_field::<u32>("move3", Self::VT_MOVE3, false)?
                .visit_field::<f32>("dynamax_boost", Self::VT_DYNAMAX_BOOST, false)?
                .visit_field::<u32>("field_1b", Self::VT_FIELD_1B, false)?
                .visit_field::<u32>("field_1c", Self::VT_FIELD_1C, false)?
                .visit_field::<u32>("shield", Self::VT_SHIELD, false)?
                .visit_field::<u32>(
                    "additional_move1_rate",
                    Self::VT_ADDITIONAL_MOVE1_RATE,
                    false,
                )?
                .visit_field::<u32>("additional_move1", Self::VT_ADDITIONAL_MOVE1, false)?
                .visit_field::<u32>("additional_move1_pp", Self::VT_ADDITIONAL_MOVE1_PP, false)?
                .visit_field::<u32>(
                    "additional_move2_rate",
                    Self::VT_ADDITIONAL_MOVE2_RATE,
                    false,
                )?
                .visit_field::<u32>("additional_move2", Self::VT_ADDITIONAL_MOVE2, false)?
                .visit_field::<u32>("additional_move2_pp", Self::VT_ADDITIONAL_MOVE2_PP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct NestHoleCrystalEncounter8Args {
        pub entry_index: u32,
        pub species: u32,
        pub alt_form: u32,
        pub level: u32,
        pub dynamax_level: i8,
        pub ability: i8,
        pub is_gigantamax: u32,
        pub drop_table_id: u64,
        pub bonus_table_id: u64,
        pub field_09: i8,
        pub field_0a: i8,
        pub field_0b: i8,
        pub field_0c: i8,
        pub field_0d: i8,
        pub nature: i8,
        pub iv_hp: i16,
        pub iv_atk: i16,
        pub iv_def: i16,
        pub iv_spatk: i16,
        pub iv_spdef: i16,
        pub iv_spe: i16,
        pub field_15: u32,
        pub move0: u32,
        pub move1: u32,
        pub move2: u32,
        pub move3: u32,
        pub dynamax_boost: f32,
        pub field_1b: u32,
        pub field_1c: u32,
        pub shield: u32,
        pub additional_move1_rate: u32,
        pub additional_move1: u32,
        pub additional_move1_pp: u32,
        pub additional_move2_rate: u32,
        pub additional_move2: u32,
        pub additional_move2_pp: u32,
    }
    impl<'a> Default for NestHoleCrystalEncounter8Args {
        #[inline]
        fn default() -> Self {
            NestHoleCrystalEncounter8Args {
                entry_index: 0,
                species: 0,
                alt_form: 0,
                level: 0,
                dynamax_level: 0,
                ability: 0,
                is_gigantamax: 0,
                drop_table_id: 0,
                bonus_table_id: 0,
                field_09: 0,
                field_0a: 0,
                field_0b: 0,
                field_0c: 0,
                field_0d: 0,
                nature: 0,
                iv_hp: 0,
                iv_atk: 0,
                iv_def: 0,
                iv_spatk: 0,
                iv_spdef: 0,
                iv_spe: 0,
                field_15: 0,
                move0: 0,
                move1: 0,
                move2: 0,
                move3: 0,
                dynamax_boost: 0.0,
                field_1b: 0,
                field_1c: 0,
                shield: 0,
                additional_move1_rate: 0,
                additional_move1: 0,
                additional_move1_pp: 0,
                additional_move2_rate: 0,
                additional_move2: 0,
                additional_move2_pp: 0,
            }
        }
    }

    pub struct NestHoleCrystalEncounter8Builder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NestHoleCrystalEncounter8Builder<'a, 'b> {
        #[inline]
        pub fn add_entry_index(&mut self, entry_index: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_ENTRY_INDEX, entry_index, 0);
        }
        #[inline]
        pub fn add_species(&mut self, species: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_SPECIES, species, 0);
        }
        #[inline]
        pub fn add_alt_form(&mut self, alt_form: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_ALT_FORM, alt_form, 0);
        }
        #[inline]
        pub fn add_level(&mut self, level: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_LEVEL, level, 0);
        }
        #[inline]
        pub fn add_dynamax_level(&mut self, dynamax_level: i8) {
            self.fbb_.push_slot::<i8>(
                NestHoleCrystalEncounter8::VT_DYNAMAX_LEVEL,
                dynamax_level,
                0,
            );
        }
        #[inline]
        pub fn add_ability(&mut self, ability: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleCrystalEncounter8::VT_ABILITY, ability, 0);
        }
        #[inline]
        pub fn add_is_gigantamax(&mut self, is_gigantamax: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleCrystalEncounter8::VT_IS_GIGANTAMAX,
                is_gigantamax,
                0,
            );
        }
        #[inline]
        pub fn add_drop_table_id(&mut self, drop_table_id: u64) {
            self.fbb_.push_slot::<u64>(
                NestHoleCrystalEncounter8::VT_DROP_TABLE_ID,
                drop_table_id,
                0,
            );
        }
        #[inline]
        pub fn add_bonus_table_id(&mut self, bonus_table_id: u64) {
            self.fbb_.push_slot::<u64>(
                NestHoleCrystalEncounter8::VT_BONUS_TABLE_ID,
                bonus_table_id,
                0,
            );
        }
        #[inline]
        pub fn add_field_09(&mut self, field_09: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleCrystalEncounter8::VT_FIELD_09, field_09, 0);
        }
        #[inline]
        pub fn add_field_0a(&mut self, field_0a: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleCrystalEncounter8::VT_FIELD_0A, field_0a, 0);
        }
        #[inline]
        pub fn add_field_0b(&mut self, field_0b: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleCrystalEncounter8::VT_FIELD_0B, field_0b, 0);
        }
        #[inline]
        pub fn add_field_0c(&mut self, field_0c: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleCrystalEncounter8::VT_FIELD_0C, field_0c, 0);
        }
        #[inline]
        pub fn add_field_0d(&mut self, field_0d: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleCrystalEncounter8::VT_FIELD_0D, field_0d, 0);
        }
        #[inline]
        pub fn add_nature(&mut self, nature: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleCrystalEncounter8::VT_NATURE, nature, 0);
        }
        #[inline]
        pub fn add_iv_hp(&mut self, iv_hp: i16) {
            self.fbb_
                .push_slot::<i16>(NestHoleCrystalEncounter8::VT_IV_HP, iv_hp, 0);
        }
        #[inline]
        pub fn add_iv_atk(&mut self, iv_atk: i16) {
            self.fbb_
                .push_slot::<i16>(NestHoleCrystalEncounter8::VT_IV_ATK, iv_atk, 0);
        }
        #[inline]
        pub fn add_iv_def(&mut self, iv_def: i16) {
            self.fbb_
                .push_slot::<i16>(NestHoleCrystalEncounter8::VT_IV_DEF, iv_def, 0);
        }
        #[inline]
        pub fn add_iv_spatk(&mut self, iv_spatk: i16) {
            self.fbb_
                .push_slot::<i16>(NestHoleCrystalEncounter8::VT_IV_SPATK, iv_spatk, 0);
        }
        #[inline]
        pub fn add_iv_spdef(&mut self, iv_spdef: i16) {
            self.fbb_
                .push_slot::<i16>(NestHoleCrystalEncounter8::VT_IV_SPDEF, iv_spdef, 0);
        }
        #[inline]
        pub fn add_iv_spe(&mut self, iv_spe: i16) {
            self.fbb_
                .push_slot::<i16>(NestHoleCrystalEncounter8::VT_IV_SPE, iv_spe, 0);
        }
        #[inline]
        pub fn add_field_15(&mut self, field_15: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_FIELD_15, field_15, 0);
        }
        #[inline]
        pub fn add_move0(&mut self, move0: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_MOVE0, move0, 0);
        }
        #[inline]
        pub fn add_move1(&mut self, move1: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_MOVE1, move1, 0);
        }
        #[inline]
        pub fn add_move2(&mut self, move2: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_MOVE2, move2, 0);
        }
        #[inline]
        pub fn add_move3(&mut self, move3: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_MOVE3, move3, 0);
        }
        #[inline]
        pub fn add_dynamax_boost(&mut self, dynamax_boost: f32) {
            self.fbb_.push_slot::<f32>(
                NestHoleCrystalEncounter8::VT_DYNAMAX_BOOST,
                dynamax_boost,
                0.0,
            );
        }
        #[inline]
        pub fn add_field_1b(&mut self, field_1b: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_FIELD_1B, field_1b, 0);
        }
        #[inline]
        pub fn add_field_1c(&mut self, field_1c: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_FIELD_1C, field_1c, 0);
        }
        #[inline]
        pub fn add_shield(&mut self, shield: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleCrystalEncounter8::VT_SHIELD, shield, 0);
        }
        #[inline]
        pub fn add_additional_move1_rate(&mut self, additional_move1_rate: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE1_RATE,
                additional_move1_rate,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move1(&mut self, additional_move1: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE1,
                additional_move1,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move1_pp(&mut self, additional_move1_pp: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE1_PP,
                additional_move1_pp,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move2_rate(&mut self, additional_move2_rate: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE2_RATE,
                additional_move2_rate,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move2(&mut self, additional_move2: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE2,
                additional_move2,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move2_pp(&mut self, additional_move2_pp: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleCrystalEncounter8::VT_ADDITIONAL_MOVE2_PP,
                additional_move2_pp,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NestHoleCrystalEncounter8Builder<'a, 'b> {
            let start = _fbb.start_table();
            NestHoleCrystalEncounter8Builder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleCrystalEncounter8<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for NestHoleCrystalEncounter8<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("NestHoleCrystalEncounter8");
            ds.field("entry_index", &self.entry_index());
            ds.field("species", &self.species());
            ds.field("alt_form", &self.alt_form());
            ds.field("level", &self.level());
            ds.field("dynamax_level", &self.dynamax_level());
            ds.field("ability", &self.ability());
            ds.field("is_gigantamax", &self.is_gigantamax());
            ds.field("drop_table_id", &self.drop_table_id());
            ds.field("bonus_table_id", &self.bonus_table_id());
            ds.field("field_09", &self.field_09());
            ds.field("field_0a", &self.field_0a());
            ds.field("field_0b", &self.field_0b());
            ds.field("field_0c", &self.field_0c());
            ds.field("field_0d", &self.field_0d());
            ds.field("nature", &self.nature());
            ds.field("iv_hp", &self.iv_hp());
            ds.field("iv_atk", &self.iv_atk());
            ds.field("iv_def", &self.iv_def());
            ds.field("iv_spatk", &self.iv_spatk());
            ds.field("iv_spdef", &self.iv_spdef());
            ds.field("iv_spe", &self.iv_spe());
            ds.field("field_15", &self.field_15());
            ds.field("move0", &self.move0());
            ds.field("move1", &self.move1());
            ds.field("move2", &self.move2());
            ds.field("move3", &self.move3());
            ds.field("dynamax_boost", &self.dynamax_boost());
            ds.field("field_1b", &self.field_1b());
            ds.field("field_1c", &self.field_1c());
            ds.field("shield", &self.shield());
            ds.field("additional_move1_rate", &self.additional_move1_rate());
            ds.field("additional_move1", &self.additional_move1());
            ds.field("additional_move1_pp", &self.additional_move1_pp());
            ds.field("additional_move2_rate", &self.additional_move2_rate());
            ds.field("additional_move2", &self.additional_move2());
            ds.field("additional_move2_pp", &self.additional_move2_pp());
            ds.finish()
        }
    }
    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_root_as_nest_hole_crystal_encounter_8archive<'a>(
        buf: &'a [u8],
    ) -> NestHoleCrystalEncounter8Archive<'a> {
        unsafe { flatbuffers::root_unchecked::<NestHoleCrystalEncounter8Archive<'a>>(buf) }
    }

    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_size_prefixed_root_as_nest_hole_crystal_encounter_8archive<'a>(
        buf: &'a [u8],
    ) -> NestHoleCrystalEncounter8Archive<'a> {
        unsafe {
            flatbuffers::size_prefixed_root_unchecked::<NestHoleCrystalEncounter8Archive<'a>>(buf)
        }
    }

    #[inline]
    /// Verifies that a buffer of bytes contains a `NestHoleCrystalEncounter8Archive`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nest_hole_crystal_encounter_8archive_unchecked`.
    pub fn root_as_nest_hole_crystal_encounter_8archive(
        buf: &[u8],
    ) -> Result<NestHoleCrystalEncounter8Archive, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<NestHoleCrystalEncounter8Archive>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `NestHoleCrystalEncounter8Archive` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_nest_hole_crystal_encounter_8archive_unchecked`.
    pub fn size_prefixed_root_as_nest_hole_crystal_encounter_8archive(
        buf: &[u8],
    ) -> Result<NestHoleCrystalEncounter8Archive, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<NestHoleCrystalEncounter8Archive>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `NestHoleCrystalEncounter8Archive` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nest_hole_crystal_encounter_8archive_unchecked`.
    pub fn root_as_nest_hole_crystal_encounter_8archive_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<NestHoleCrystalEncounter8Archive<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<NestHoleCrystalEncounter8Archive<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `NestHoleCrystalEncounter8Archive` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nest_hole_crystal_encounter_8archive_unchecked`.
    pub fn size_prefixed_root_as_nest_hole_crystal_encounter_8archive_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<NestHoleCrystalEncounter8Archive<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<NestHoleCrystalEncounter8Archive<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a NestHoleCrystalEncounter8Archive and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `NestHoleCrystalEncounter8Archive`.
    pub unsafe fn root_as_nest_hole_crystal_encounter_8archive_unchecked(
        buf: &[u8],
    ) -> NestHoleCrystalEncounter8Archive {
        flatbuffers::root_unchecked::<NestHoleCrystalEncounter8Archive>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed NestHoleCrystalEncounter8Archive and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `NestHoleCrystalEncounter8Archive`.
    pub unsafe fn size_prefixed_root_as_nest_hole_crystal_encounter_8archive_unchecked(
        buf: &[u8],
    ) -> NestHoleCrystalEncounter8Archive {
        flatbuffers::size_prefixed_root_unchecked::<NestHoleCrystalEncounter8Archive>(buf)
    }
    pub const NEST_HOLE_CRYSTAL_ENCOUNTER_8ARCHIVE_EXTENSION: &str = "bin";

    #[inline]
    pub fn finish_nest_hole_crystal_encounter_8archive_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<NestHoleCrystalEncounter8Archive<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_nest_hole_crystal_encounter_8archive_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<NestHoleCrystalEncounter8Archive<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod structure
