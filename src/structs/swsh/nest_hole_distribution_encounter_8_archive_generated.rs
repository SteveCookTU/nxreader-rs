// automatically generated by the FlatBuffers compiler, do not modify

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod structure {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum NestHoleDistributionEncounter8ArchiveOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NestHoleDistributionEncounter8Archive<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> Follow<'a> for NestHoleDistributionEncounter8Archive<'a> {
        type Inner = NestHoleDistributionEncounter8Archive<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NestHoleDistributionEncounter8Archive<'a> {
        pub const VT_TABLES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NestHoleDistributionEncounter8Archive { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NestHoleDistributionEncounter8ArchiveArgs<'args>,
        ) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8Archive<'bldr>> {
            let mut builder = NestHoleDistributionEncounter8ArchiveBuilder::new(_fbb);
            if let Some(x) = args.tables {
                builder.add_tables(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn tables(
            &self,
        ) -> Option<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table<'a>>,
            >,
        > {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table>,
                >,
            >>(NestHoleDistributionEncounter8Archive::VT_TABLES, None)
        }
    }

    impl flatbuffers::Verifiable for NestHoleDistributionEncounter8Archive<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<
                        '_,
                        flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table>,
                    >,
                >>("tables", Self::VT_TABLES, false)?
                .finish();
            Ok(())
        }
    }

    #[derive(Default)]
    pub struct NestHoleDistributionEncounter8ArchiveArgs<'a> {
        pub tables: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table<'a>>,
                >,
            >,
        >,
    }

    pub struct NestHoleDistributionEncounter8ArchiveBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NestHoleDistributionEncounter8ArchiveBuilder<'a, 'b> {
        #[inline]
        pub fn add_tables(
            &mut self,
            tables: flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'b,
                    flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table<'b>>,
                >,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NestHoleDistributionEncounter8Archive::VT_TABLES,
                tables,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NestHoleDistributionEncounter8ArchiveBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NestHoleDistributionEncounter8ArchiveBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8Archive<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for NestHoleDistributionEncounter8Archive<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("NestHoleDistributionEncounter8Archive");
            ds.field("tables", &self.tables());
            ds.finish()
        }
    }
    pub enum NestHoleDistributionEncounter8TableOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NestHoleDistributionEncounter8Table<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> Follow<'a> for NestHoleDistributionEncounter8Table<'a> {
        type Inner = NestHoleDistributionEncounter8Table<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NestHoleDistributionEncounter8Table<'a> {
        pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_GAME_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_FIELD_02: flatbuffers::VOffsetT = 8;
        pub const VT_FIELD_03: flatbuffers::VOffsetT = 10;
        pub const VT_ENTRIES: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NestHoleDistributionEncounter8Table { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NestHoleDistributionEncounter8TableArgs<'args>,
        ) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8Table<'bldr>> {
            let mut builder = NestHoleDistributionEncounter8TableBuilder::new(_fbb);
            builder.add_table_id(args.table_id);
            if let Some(x) = args.entries {
                builder.add_entries(x);
            }
            builder.add_game_version(args.game_version);
            builder.add_field_03(args.field_03);
            builder.add_field_02(args.field_02);
            builder.finish()
        }

        #[inline]
        pub fn table_id(&self) -> u64 {
            self._tab
                .get::<u64>(NestHoleDistributionEncounter8Table::VT_TABLE_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn game_version(&self) -> u32 {
            self._tab
                .get::<u32>(
                    NestHoleDistributionEncounter8Table::VT_GAME_VERSION,
                    Some(0),
                )
                .unwrap()
        }
        #[inline]
        pub fn field_02(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8Table::VT_FIELD_02, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_03(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8Table::VT_FIELD_03, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn entries(
            &self,
        ) -> Option<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8<'a>>,
            >,
        > {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8>,
                >,
            >>(NestHoleDistributionEncounter8Table::VT_ENTRIES, None)
        }
    }

    impl flatbuffers::Verifiable for NestHoleDistributionEncounter8Table<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("table_id", Self::VT_TABLE_ID, false)?
                .visit_field::<u32>("game_version", Self::VT_GAME_VERSION, false)?
                .visit_field::<i8>("field_02", Self::VT_FIELD_02, false)?
                .visit_field::<i8>("field_03", Self::VT_FIELD_03, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<
                        '_,
                        flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8>,
                    >,
                >>("entries", Self::VT_ENTRIES, false)?
                .finish();
            Ok(())
        }
    }

    #[derive(Default)]
    pub struct NestHoleDistributionEncounter8TableArgs<'a> {
        pub table_id: u64,
        pub game_version: u32,
        pub field_02: i8,
        pub field_03: i8,
        pub entries: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8<'a>>,
                >,
            >,
        >,
    }

    pub struct NestHoleDistributionEncounter8TableBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NestHoleDistributionEncounter8TableBuilder<'a, 'b> {
        #[inline]
        pub fn add_table_id(&mut self, table_id: u64) {
            self.fbb_.push_slot::<u64>(
                NestHoleDistributionEncounter8Table::VT_TABLE_ID,
                table_id,
                0,
            );
        }
        #[inline]
        pub fn add_game_version(&mut self, game_version: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleDistributionEncounter8Table::VT_GAME_VERSION,
                game_version,
                0,
            );
        }
        #[inline]
        pub fn add_field_02(&mut self, field_02: i8) {
            self.fbb_.push_slot::<i8>(
                NestHoleDistributionEncounter8Table::VT_FIELD_02,
                field_02,
                0,
            );
        }
        #[inline]
        pub fn add_field_03(&mut self, field_03: i8) {
            self.fbb_.push_slot::<i8>(
                NestHoleDistributionEncounter8Table::VT_FIELD_03,
                field_03,
                0,
            );
        }
        #[inline]
        pub fn add_entries(
            &mut self,
            entries: flatbuffers::WIPOffset<
                flatbuffers::Vector<
                    'b,
                    flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8<'b>>,
                >,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NestHoleDistributionEncounter8Table::VT_ENTRIES,
                entries,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NestHoleDistributionEncounter8TableBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NestHoleDistributionEncounter8TableBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8Table<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for NestHoleDistributionEncounter8Table<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("NestHoleDistributionEncounter8Table");
            ds.field("table_id", &self.table_id());
            ds.field("game_version", &self.game_version());
            ds.field("field_02", &self.field_02());
            ds.field("field_03", &self.field_03());
            ds.field("entries", &self.entries());
            ds.finish()
        }
    }
    pub enum NestHoleDistributionEncounter8Offset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NestHoleDistributionEncounter8<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> Follow<'a> for NestHoleDistributionEncounter8<'a> {
        type Inner = NestHoleDistributionEncounter8<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> NestHoleDistributionEncounter8<'a> {
        pub const VT_ENTRY_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_SPECIES: flatbuffers::VOffsetT = 6;
        pub const VT_ALT_FORM: flatbuffers::VOffsetT = 8;
        pub const VT_LEVEL: flatbuffers::VOffsetT = 10;
        pub const VT_DYNAMAX_LEVEL: flatbuffers::VOffsetT = 12;
        pub const VT_FIELD_05: flatbuffers::VOffsetT = 14;
        pub const VT_FIELD_06: flatbuffers::VOffsetT = 16;
        pub const VT_FIELD_07: flatbuffers::VOffsetT = 18;
        pub const VT_FIELD_08: flatbuffers::VOffsetT = 20;
        pub const VT_FIELD_09: flatbuffers::VOffsetT = 22;
        pub const VT_FIELD_0A: flatbuffers::VOffsetT = 24;
        pub const VT_ABILITY: flatbuffers::VOffsetT = 26;
        pub const VT_IS_GIGANTAMAX: flatbuffers::VOffsetT = 28;
        pub const VT_DROP_TABLE_ID: flatbuffers::VOffsetT = 30;
        pub const VT_BONUS_TABLE_ID: flatbuffers::VOffsetT = 32;
        pub const VT_PROBABILITIES: flatbuffers::VOffsetT = 34;
        pub const VT_GENDER: flatbuffers::VOffsetT = 36;
        pub const VT_FLAWLESS_IVS: flatbuffers::VOffsetT = 38;
        pub const VT_SHINY_FLAG: flatbuffers::VOffsetT = 40;
        pub const VT_FIELD_13: flatbuffers::VOffsetT = 42;
        pub const VT_FIELD_14: flatbuffers::VOffsetT = 44;
        pub const VT_NATURE: flatbuffers::VOffsetT = 46;
        pub const VT_FIELD_16: flatbuffers::VOffsetT = 48;
        pub const VT_MOVE0: flatbuffers::VOffsetT = 50;
        pub const VT_MOVE1: flatbuffers::VOffsetT = 52;
        pub const VT_MOVE2: flatbuffers::VOffsetT = 54;
        pub const VT_MOVE3: flatbuffers::VOffsetT = 56;
        pub const VT_DYNAMAX_BOOST: flatbuffers::VOffsetT = 58;
        pub const VT_FIELD_1C: flatbuffers::VOffsetT = 60;
        pub const VT_FIELD_1D: flatbuffers::VOffsetT = 62;
        pub const VT_SHIELD: flatbuffers::VOffsetT = 64;
        pub const VT_ADDITIONAL_MOVE1_RATE: flatbuffers::VOffsetT = 66;
        pub const VT_ADDITIONAL_MOVE1: flatbuffers::VOffsetT = 68;
        pub const VT_ADDITIONAL_MOVE1_PP: flatbuffers::VOffsetT = 70;
        pub const VT_ADDITIONAL_MOVE2_RATE: flatbuffers::VOffsetT = 72;
        pub const VT_ADDITIONAL_MOVE2: flatbuffers::VOffsetT = 74;
        pub const VT_ADDITIONAL_MOVE2_PP: flatbuffers::VOffsetT = 76;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NestHoleDistributionEncounter8 { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NestHoleDistributionEncounter8Args<'args>,
        ) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8<'bldr>> {
            let mut builder = NestHoleDistributionEncounter8Builder::new(_fbb);
            builder.add_bonus_table_id(args.bonus_table_id);
            builder.add_drop_table_id(args.drop_table_id);
            builder.add_additional_move2_pp(args.additional_move2_pp);
            builder.add_additional_move2(args.additional_move2);
            builder.add_additional_move2_rate(args.additional_move2_rate);
            builder.add_additional_move1_pp(args.additional_move1_pp);
            builder.add_additional_move1(args.additional_move1);
            builder.add_additional_move1_rate(args.additional_move1_rate);
            builder.add_shield(args.shield);
            builder.add_field_1d(args.field_1d);
            builder.add_field_1c(args.field_1c);
            builder.add_dynamax_boost(args.dynamax_boost);
            builder.add_move3(args.move3);
            builder.add_move2(args.move2);
            builder.add_move1(args.move1);
            builder.add_move0(args.move0);
            builder.add_field_16(args.field_16);
            if let Some(x) = args.probabilities {
                builder.add_probabilities(x);
            }
            builder.add_field_0a(args.field_0a);
            builder.add_field_09(args.field_09);
            builder.add_field_08(args.field_08);
            builder.add_field_07(args.field_07);
            builder.add_field_06(args.field_06);
            builder.add_field_05(args.field_05);
            builder.add_level(args.level);
            builder.add_alt_form(args.alt_form);
            builder.add_species(args.species);
            builder.add_entry_index(args.entry_index);
            builder.add_dynamax_level(args.dynamax_level);
            builder.add_nature(args.nature);
            builder.add_field_14(args.field_14);
            builder.add_field_13(args.field_13);
            builder.add_shiny_flag(args.shiny_flag);
            builder.add_flawless_ivs(args.flawless_ivs);
            builder.add_gender(args.gender);
            builder.add_is_gigantamax(args.is_gigantamax);
            builder.add_ability(args.ability);
            builder.finish()
        }

        #[inline]
        pub fn entry_index(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_ENTRY_INDEX, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn species(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_SPECIES, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn alt_form(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_ALT_FORM, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn level(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_LEVEL, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn dynamax_level(&self) -> u16 {
            self._tab
                .get::<u16>(NestHoleDistributionEncounter8::VT_DYNAMAX_LEVEL, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_05(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_05, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_06(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_06, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_07(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_07, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_08(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_08, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_09(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_09, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_0a(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_0A, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn ability(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8::VT_ABILITY, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn is_gigantamax(&self) -> bool {
            self._tab
                .get::<bool>(
                    NestHoleDistributionEncounter8::VT_IS_GIGANTAMAX,
                    Some(false),
                )
                .unwrap()
        }
        #[inline]
        pub fn drop_table_id(&self) -> u64 {
            self._tab
                .get::<u64>(NestHoleDistributionEncounter8::VT_DROP_TABLE_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn bonus_table_id(&self) -> u64 {
            self._tab
                .get::<u64>(NestHoleDistributionEncounter8::VT_BONUS_TABLE_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn probabilities(&self) -> Option<flatbuffers::Vector<'a, u32>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    NestHoleDistributionEncounter8::VT_PROBABILITIES,
                    None,
                )
        }
        #[inline]
        pub fn gender(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8::VT_GENDER, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn flawless_ivs(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8::VT_FLAWLESS_IVS, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn shiny_flag(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8::VT_SHINY_FLAG, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_13(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8::VT_FIELD_13, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_14(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8::VT_FIELD_14, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn nature(&self) -> i8 {
            self._tab
                .get::<i8>(NestHoleDistributionEncounter8::VT_NATURE, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_16(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_16, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn move0(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_MOVE0, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn move1(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_MOVE1, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn move2(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_MOVE2, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn move3(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_MOVE3, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn dynamax_boost(&self) -> f32 {
            self._tab
                .get::<f32>(NestHoleDistributionEncounter8::VT_DYNAMAX_BOOST, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn field_1c(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_1C, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_1d(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_1D, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn shield(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_SHIELD, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move1_rate(&self) -> u32 {
            self._tab
                .get::<u32>(
                    NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE1_RATE,
                    Some(0),
                )
                .unwrap()
        }
        #[inline]
        pub fn additional_move1(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE1, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move1_pp(&self) -> u32 {
            self._tab
                .get::<u32>(
                    NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE1_PP,
                    Some(0),
                )
                .unwrap()
        }
        #[inline]
        pub fn additional_move2_rate(&self) -> u32 {
            self._tab
                .get::<u32>(
                    NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE2_RATE,
                    Some(0),
                )
                .unwrap()
        }
        #[inline]
        pub fn additional_move2(&self) -> u32 {
            self._tab
                .get::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE2, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn additional_move2_pp(&self) -> u32 {
            self._tab
                .get::<u32>(
                    NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE2_PP,
                    Some(0),
                )
                .unwrap()
        }
    }

    impl flatbuffers::Verifiable for NestHoleDistributionEncounter8<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("entry_index", Self::VT_ENTRY_INDEX, false)?
                .visit_field::<u32>("species", Self::VT_SPECIES, false)?
                .visit_field::<u32>("alt_form", Self::VT_ALT_FORM, false)?
                .visit_field::<u32>("level", Self::VT_LEVEL, false)?
                .visit_field::<u16>("dynamax_level", Self::VT_DYNAMAX_LEVEL, false)?
                .visit_field::<u32>("field_05", Self::VT_FIELD_05, false)?
                .visit_field::<u32>("field_06", Self::VT_FIELD_06, false)?
                .visit_field::<u32>("field_07", Self::VT_FIELD_07, false)?
                .visit_field::<u32>("field_08", Self::VT_FIELD_08, false)?
                .visit_field::<u32>("field_09", Self::VT_FIELD_09, false)?
                .visit_field::<u32>("field_0a", Self::VT_FIELD_0A, false)?
                .visit_field::<i8>("ability", Self::VT_ABILITY, false)?
                .visit_field::<bool>("is_gigantamax", Self::VT_IS_GIGANTAMAX, false)?
                .visit_field::<u64>("drop_table_id", Self::VT_DROP_TABLE_ID, false)?
                .visit_field::<u64>("bonus_table_id", Self::VT_BONUS_TABLE_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                    "probabilities",
                    Self::VT_PROBABILITIES,
                    false,
                )?
                .visit_field::<i8>("gender", Self::VT_GENDER, false)?
                .visit_field::<i8>("flawless_ivs", Self::VT_FLAWLESS_IVS, false)?
                .visit_field::<i8>("shiny_flag", Self::VT_SHINY_FLAG, false)?
                .visit_field::<i8>("field_13", Self::VT_FIELD_13, false)?
                .visit_field::<i8>("field_14", Self::VT_FIELD_14, false)?
                .visit_field::<i8>("nature", Self::VT_NATURE, false)?
                .visit_field::<u32>("field_16", Self::VT_FIELD_16, false)?
                .visit_field::<u32>("move0", Self::VT_MOVE0, false)?
                .visit_field::<u32>("move1", Self::VT_MOVE1, false)?
                .visit_field::<u32>("move2", Self::VT_MOVE2, false)?
                .visit_field::<u32>("move3", Self::VT_MOVE3, false)?
                .visit_field::<f32>("dynamax_boost", Self::VT_DYNAMAX_BOOST, false)?
                .visit_field::<u32>("field_1c", Self::VT_FIELD_1C, false)?
                .visit_field::<u32>("field_1d", Self::VT_FIELD_1D, false)?
                .visit_field::<u32>("shield", Self::VT_SHIELD, false)?
                .visit_field::<u32>(
                    "additional_move1_rate",
                    Self::VT_ADDITIONAL_MOVE1_RATE,
                    false,
                )?
                .visit_field::<u32>("additional_move1", Self::VT_ADDITIONAL_MOVE1, false)?
                .visit_field::<u32>("additional_move1_pp", Self::VT_ADDITIONAL_MOVE1_PP, false)?
                .visit_field::<u32>(
                    "additional_move2_rate",
                    Self::VT_ADDITIONAL_MOVE2_RATE,
                    false,
                )?
                .visit_field::<u32>("additional_move2", Self::VT_ADDITIONAL_MOVE2, false)?
                .visit_field::<u32>("additional_move2_pp", Self::VT_ADDITIONAL_MOVE2_PP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct NestHoleDistributionEncounter8Args<'a> {
        pub entry_index: u32,
        pub species: u32,
        pub alt_form: u32,
        pub level: u32,
        pub dynamax_level: u16,
        pub field_05: u32,
        pub field_06: u32,
        pub field_07: u32,
        pub field_08: u32,
        pub field_09: u32,
        pub field_0a: u32,
        pub ability: i8,
        pub is_gigantamax: bool,
        pub drop_table_id: u64,
        pub bonus_table_id: u64,
        pub probabilities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        pub gender: i8,
        pub flawless_ivs: i8,
        pub shiny_flag: i8,
        pub field_13: i8,
        pub field_14: i8,
        pub nature: i8,
        pub field_16: u32,
        pub move0: u32,
        pub move1: u32,
        pub move2: u32,
        pub move3: u32,
        pub dynamax_boost: f32,
        pub field_1c: u32,
        pub field_1d: u32,
        pub shield: u32,
        pub additional_move1_rate: u32,
        pub additional_move1: u32,
        pub additional_move1_pp: u32,
        pub additional_move2_rate: u32,
        pub additional_move2: u32,
        pub additional_move2_pp: u32,
    }
    impl<'a> Default for NestHoleDistributionEncounter8Args<'a> {
        #[inline]
        fn default() -> Self {
            NestHoleDistributionEncounter8Args {
                entry_index: 0,
                species: 0,
                alt_form: 0,
                level: 0,
                dynamax_level: 0,
                field_05: 0,
                field_06: 0,
                field_07: 0,
                field_08: 0,
                field_09: 0,
                field_0a: 0,
                ability: 0,
                is_gigantamax: false,
                drop_table_id: 0,
                bonus_table_id: 0,
                probabilities: None,
                gender: 0,
                flawless_ivs: 0,
                shiny_flag: 0,
                field_13: 0,
                field_14: 0,
                nature: 0,
                field_16: 0,
                move0: 0,
                move1: 0,
                move2: 0,
                move3: 0,
                dynamax_boost: 0.0,
                field_1c: 0,
                field_1d: 0,
                shield: 0,
                additional_move1_rate: 0,
                additional_move1: 0,
                additional_move1_pp: 0,
                additional_move2_rate: 0,
                additional_move2: 0,
                additional_move2_pp: 0,
            }
        }
    }

    pub struct NestHoleDistributionEncounter8Builder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NestHoleDistributionEncounter8Builder<'a, 'b> {
        #[inline]
        pub fn add_entry_index(&mut self, entry_index: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleDistributionEncounter8::VT_ENTRY_INDEX,
                entry_index,
                0,
            );
        }
        #[inline]
        pub fn add_species(&mut self, species: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_SPECIES, species, 0);
        }
        #[inline]
        pub fn add_alt_form(&mut self, alt_form: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_ALT_FORM, alt_form, 0);
        }
        #[inline]
        pub fn add_level(&mut self, level: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_LEVEL, level, 0);
        }
        #[inline]
        pub fn add_dynamax_level(&mut self, dynamax_level: u16) {
            self.fbb_.push_slot::<u16>(
                NestHoleDistributionEncounter8::VT_DYNAMAX_LEVEL,
                dynamax_level,
                0,
            );
        }
        #[inline]
        pub fn add_field_05(&mut self, field_05: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_05, field_05, 0);
        }
        #[inline]
        pub fn add_field_06(&mut self, field_06: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_06, field_06, 0);
        }
        #[inline]
        pub fn add_field_07(&mut self, field_07: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_07, field_07, 0);
        }
        #[inline]
        pub fn add_field_08(&mut self, field_08: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_08, field_08, 0);
        }
        #[inline]
        pub fn add_field_09(&mut self, field_09: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_09, field_09, 0);
        }
        #[inline]
        pub fn add_field_0a(&mut self, field_0a: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_0A, field_0a, 0);
        }
        #[inline]
        pub fn add_ability(&mut self, ability: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleDistributionEncounter8::VT_ABILITY, ability, 0);
        }
        #[inline]
        pub fn add_is_gigantamax(&mut self, is_gigantamax: bool) {
            self.fbb_.push_slot::<bool>(
                NestHoleDistributionEncounter8::VT_IS_GIGANTAMAX,
                is_gigantamax,
                false,
            );
        }
        #[inline]
        pub fn add_drop_table_id(&mut self, drop_table_id: u64) {
            self.fbb_.push_slot::<u64>(
                NestHoleDistributionEncounter8::VT_DROP_TABLE_ID,
                drop_table_id,
                0,
            );
        }
        #[inline]
        pub fn add_bonus_table_id(&mut self, bonus_table_id: u64) {
            self.fbb_.push_slot::<u64>(
                NestHoleDistributionEncounter8::VT_BONUS_TABLE_ID,
                bonus_table_id,
                0,
            );
        }
        #[inline]
        pub fn add_probabilities(
            &mut self,
            probabilities: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NestHoleDistributionEncounter8::VT_PROBABILITIES,
                probabilities,
            );
        }
        #[inline]
        pub fn add_gender(&mut self, gender: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleDistributionEncounter8::VT_GENDER, gender, 0);
        }
        #[inline]
        pub fn add_flawless_ivs(&mut self, flawless_ivs: i8) {
            self.fbb_.push_slot::<i8>(
                NestHoleDistributionEncounter8::VT_FLAWLESS_IVS,
                flawless_ivs,
                0,
            );
        }
        #[inline]
        pub fn add_shiny_flag(&mut self, shiny_flag: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleDistributionEncounter8::VT_SHINY_FLAG, shiny_flag, 0);
        }
        #[inline]
        pub fn add_field_13(&mut self, field_13: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleDistributionEncounter8::VT_FIELD_13, field_13, 0);
        }
        #[inline]
        pub fn add_field_14(&mut self, field_14: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleDistributionEncounter8::VT_FIELD_14, field_14, 0);
        }
        #[inline]
        pub fn add_nature(&mut self, nature: i8) {
            self.fbb_
                .push_slot::<i8>(NestHoleDistributionEncounter8::VT_NATURE, nature, 0);
        }
        #[inline]
        pub fn add_field_16(&mut self, field_16: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_16, field_16, 0);
        }
        #[inline]
        pub fn add_move0(&mut self, move0: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_MOVE0, move0, 0);
        }
        #[inline]
        pub fn add_move1(&mut self, move1: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_MOVE1, move1, 0);
        }
        #[inline]
        pub fn add_move2(&mut self, move2: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_MOVE2, move2, 0);
        }
        #[inline]
        pub fn add_move3(&mut self, move3: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_MOVE3, move3, 0);
        }
        #[inline]
        pub fn add_dynamax_boost(&mut self, dynamax_boost: f32) {
            self.fbb_.push_slot::<f32>(
                NestHoleDistributionEncounter8::VT_DYNAMAX_BOOST,
                dynamax_boost,
                0.0,
            );
        }
        #[inline]
        pub fn add_field_1c(&mut self, field_1c: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_1C, field_1c, 0);
        }
        #[inline]
        pub fn add_field_1d(&mut self, field_1d: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_1D, field_1d, 0);
        }
        #[inline]
        pub fn add_shield(&mut self, shield: u32) {
            self.fbb_
                .push_slot::<u32>(NestHoleDistributionEncounter8::VT_SHIELD, shield, 0);
        }
        #[inline]
        pub fn add_additional_move1_rate(&mut self, additional_move1_rate: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE1_RATE,
                additional_move1_rate,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move1(&mut self, additional_move1: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE1,
                additional_move1,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move1_pp(&mut self, additional_move1_pp: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE1_PP,
                additional_move1_pp,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move2_rate(&mut self, additional_move2_rate: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE2_RATE,
                additional_move2_rate,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move2(&mut self, additional_move2: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE2,
                additional_move2,
                0,
            );
        }
        #[inline]
        pub fn add_additional_move2_pp(&mut self, additional_move2_pp: u32) {
            self.fbb_.push_slot::<u32>(
                NestHoleDistributionEncounter8::VT_ADDITIONAL_MOVE2_PP,
                additional_move2_pp,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NestHoleDistributionEncounter8Builder<'a, 'b> {
            let start = _fbb.start_table();
            NestHoleDistributionEncounter8Builder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl std::fmt::Debug for NestHoleDistributionEncounter8<'_> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut ds = f.debug_struct("NestHoleDistributionEncounter8");
            ds.field("entry_index", &self.entry_index());
            ds.field("species", &self.species());
            ds.field("alt_form", &self.alt_form());
            ds.field("level", &self.level());
            ds.field("dynamax_level", &self.dynamax_level());
            ds.field("field_05", &self.field_05());
            ds.field("field_06", &self.field_06());
            ds.field("field_07", &self.field_07());
            ds.field("field_08", &self.field_08());
            ds.field("field_09", &self.field_09());
            ds.field("field_0a", &self.field_0a());
            ds.field("ability", &self.ability());
            ds.field("is_gigantamax", &self.is_gigantamax());
            ds.field("drop_table_id", &self.drop_table_id());
            ds.field("bonus_table_id", &self.bonus_table_id());
            ds.field("probabilities", &self.probabilities());
            ds.field("gender", &self.gender());
            ds.field("flawless_ivs", &self.flawless_ivs());
            ds.field("shiny_flag", &self.shiny_flag());
            ds.field("field_13", &self.field_13());
            ds.field("field_14", &self.field_14());
            ds.field("nature", &self.nature());
            ds.field("field_16", &self.field_16());
            ds.field("move0", &self.move0());
            ds.field("move1", &self.move1());
            ds.field("move2", &self.move2());
            ds.field("move3", &self.move3());
            ds.field("dynamax_boost", &self.dynamax_boost());
            ds.field("field_1c", &self.field_1c());
            ds.field("field_1d", &self.field_1d());
            ds.field("shield", &self.shield());
            ds.field("additional_move1_rate", &self.additional_move1_rate());
            ds.field("additional_move1", &self.additional_move1());
            ds.field("additional_move1_pp", &self.additional_move1_pp());
            ds.field("additional_move2_rate", &self.additional_move2_rate());
            ds.field("additional_move2", &self.additional_move2());
            ds.field("additional_move2_pp", &self.additional_move2_pp());
            ds.finish()
        }
    }
    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_root_as_nest_hole_distribution_encounter_8archive<'a>(
        buf: &'a [u8],
    ) -> NestHoleDistributionEncounter8Archive<'a> {
        unsafe { flatbuffers::root_unchecked::<NestHoleDistributionEncounter8Archive<'a>>(buf) }
    }

    #[inline]
    #[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
    pub fn get_size_prefixed_root_as_nest_hole_distribution_encounter_8archive<'a>(
        buf: &'a [u8],
    ) -> NestHoleDistributionEncounter8Archive<'a> {
        unsafe {
            flatbuffers::size_prefixed_root_unchecked::<NestHoleDistributionEncounter8Archive<'a>>(
                buf,
            )
        }
    }

    #[inline]
    /// Verifies that a buffer of bytes contains a `NestHoleDistributionEncounter8Archive`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nest_hole_distribution_encounter_8archive_unchecked`.
    pub fn root_as_nest_hole_distribution_encounter_8archive(
        buf: &[u8],
    ) -> Result<NestHoleDistributionEncounter8Archive, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<NestHoleDistributionEncounter8Archive>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `NestHoleDistributionEncounter8Archive` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_nest_hole_distribution_encounter_8archive_unchecked`.
    pub fn size_prefixed_root_as_nest_hole_distribution_encounter_8archive(
        buf: &[u8],
    ) -> Result<NestHoleDistributionEncounter8Archive, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<NestHoleDistributionEncounter8Archive>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `NestHoleDistributionEncounter8Archive` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nest_hole_distribution_encounter_8archive_unchecked`.
    pub fn root_as_nest_hole_distribution_encounter_8archive_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<NestHoleDistributionEncounter8Archive<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<NestHoleDistributionEncounter8Archive<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `NestHoleDistributionEncounter8Archive` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_nest_hole_distribution_encounter_8archive_unchecked`.
    pub fn size_prefixed_root_as_nest_hole_distribution_encounter_8archive_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<NestHoleDistributionEncounter8Archive<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<NestHoleDistributionEncounter8Archive<'b>>(
            opts, buf,
        )
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a NestHoleDistributionEncounter8Archive and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `NestHoleDistributionEncounter8Archive`.
    pub unsafe fn root_as_nest_hole_distribution_encounter_8archive_unchecked(
        buf: &[u8],
    ) -> NestHoleDistributionEncounter8Archive {
        flatbuffers::root_unchecked::<NestHoleDistributionEncounter8Archive>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed NestHoleDistributionEncounter8Archive and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `NestHoleDistributionEncounter8Archive`.
    pub unsafe fn size_prefixed_root_as_nest_hole_distribution_encounter_8archive_unchecked(
        buf: &[u8],
    ) -> NestHoleDistributionEncounter8Archive {
        flatbuffers::size_prefixed_root_unchecked::<NestHoleDistributionEncounter8Archive>(buf)
    }
    pub const NEST_HOLE_DISTRIBUTION_ENCOUNTER_8ARCHIVE_EXTENSION: &str = "bin";

    #[inline]
    pub fn finish_nest_hole_distribution_encounter_8archive_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<NestHoleDistributionEncounter8Archive<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_nest_hole_distribution_encounter_8archive_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<NestHoleDistributionEncounter8Archive<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod structure
